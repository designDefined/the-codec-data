{"id":4,"title":"Be Water, My Layout: CSS Flexbox가 제시하는 레이아웃 스타일링의 새로운 관점","content":{"id":"root-sample","name":"root","type":"OUTER_BOX","layout":{"px":0,"py":0,"g":48},"look":{},"children":[{"id":"container-sample","name":"sample","type":"INNER_BOX","layout":{},"look":{},"children":[{"type":"HEADING","children":[{"text":"Be Water, My Layout","bold":true}],"level":1}]},{"id":"PiLjgqjWrpmbudYGcx3T3","name":"new box 2","type":"INNER_BOX","layout":{},"look":{},"children":[{"type":"PARAGRAPH","children":[{"text":"CSS Flexbox가 제시하는 레이아웃 스타일링의 새로운 관점"}]}]},{"id":"hT_FpOw50digm1pnzIWY2","name":"new box 3","type":"INNER_BOX","layout":{},"look":{},"children":[{"type":"PARAGRAPH","children":[{"text":"인트로1"}]}]},{"id":"4THaNi07UoIsJK6UDzxwn","name":"new box 4","type":"INNER_BOX","layout":{},"look":{},"children":[{"type":"PARAGRAPH","children":[{"text":"인트로2"}]}]},{"id":"4xz_PehhoIPeEGq3BRMlE","name":"new box 5","type":"INNER_BOX","layout":{},"look":{},"children":[{"type":"PARAGRAPH","children":[{"text":"CSS로 레이아웃을 그리기가 어려운 이유","bold":true}]},{"type":"PARAGRAPH","children":[{"text":"CSS 작업은 즐겁습니다. 단순히 코드 조각에 불과했던 UI가 비로소 "},{"text":"눈에 보이는 실체","bold":true},{"text":"로 거듭나는 순간이기 때문입니다. 코드 한 줄 한 줄이 화면 전체의 인상을 바꾸거나, UI를 살아 숨쉬는 상호작용의 주체로 만들기도 하고, 디자이너, 기획자와 함께 꿈꾸던 모습으로 서비스를 완성시킬 수도 있는 CSS는 참 매력적이게 느껴집니다. 그러나"},{"text":" CSS 작업이 ","bold":false},{"bold":true,"text":"항상"},{"bold":false,"text":" 즐거운가요?"},{"text":" 저는 '아니다'라고 자신있게 대답할 수 있습니다. 여러분은 분명 마음대로 되지 않는 CSS 때문에 밤을 지새워본 적이 있을 겁니다. 화면을 너무 복잡하게 구현한 디자이너나, 이해할 수 없는 CSS 문법을 도입한 선대의 웹 개발자들을 원망하면서 말이죠. "}]},{"type":"PARAGRAPH","children":[{"text":"저의 경우에는 화면의 전반적인 "},{"text":"레이아웃","bold":true},{"text":"을 잡는 작업이 특히 까다롭게 느껴졌습니다. 레이아웃은 UI 요소들을 화면의 적절한 위치에 배치하는 것을 의미합니다. 프로젝트를 처음 시작할 때에는 디자인 시스템을 백지에서부터 구현하는 작업에 시간을 많이 소모합니다. 레이아웃은 큰 문제가 아니게 느껴집니다. 그러나 프로젝트가 점점 확장되고 (...)"}]},{"type":"PARAGRAPH","children":[{"text":"첫째, 레이아웃은 너무 "},{"text":"각양각색","bold":true},{"text":"입니다. 초기 작업이 끝나고 나면 페이지가 10개, 20개 늘어나더라도 버튼 디자인의 가짓수는 크게 늘어나지 않습니다. 텍스트 입력창이나 모달, 셀렉트박스의 디자인도 마찬가지죠. 그러나 그 페이지들이 "},{"text":"모두 다른 레이아웃을 ","bold":false},{"text":"가지고 있다고 해도 그리 놀라운 일은 아닐 겁니다. 화면의 기능과 사용 방법에 따라 요소들의 "},{"text":"배치를 최적화","bold":true},{"text":"할 필요가 있기 때문입니다. 서로 다른 기능을 가진 10개의 페이지가 추가되었다면, 이에 최적화된 10개의 레이아웃 또한 추가되는 것이죠."}]},{"type":"PARAGRAPH","children":[{"text":"둘째, CSS로 요소를 배치하는 작업은 "},{"text":"직관적이지 않습니다","bold":true},{"text":". 드래그 & 드롭으로 UI 컴포넌트를 눈에 보이는 위치에 바로 배치할 수 있다면 참 좋겠지만 CSS는 그리 호락호락하지 않죠. 우리는 padding, margin, gap과 같은 속성으로 부모와 자식 요소들과의 거리를 조절하며 레이아웃을 '쌓아올려야' 하고, 정렬 하나를 위해서도 float와 flex, align, justify, wrap 등 수많은 속성의 동작 방식을 알아야 합니다. 뿐만 아니라 작업을 하다보면 단지 레이아웃만을 위한 HTML 태그들이 추가되고 여기에 .container, .wrapper, .wrapper-container와 같은 추상적인 클래스명이 붙는데, 이는 코드의 가독성을 크게 떨어뜨리기도 합니다."}]},{"type":"PARAGRAPH","children":[{"text":"셋째, 레이아웃은 "},{"text":"자주 수정됩니다","bold":true},{"text":". 기능에 변경이 없더라도 사용자의 편의를 위해 요소를 재배치하는 일은 종종 일어납니다. 또 화면에 한 두 요소가 추가되었을 뿐인데 기존의 레이아웃이 전반적으로 변경되는 경우도 비일비재하죠. "},{"text":"'클린 아키텍쳐'","bold":false},{"text":"에서 로버트 C 마틴이 "},{"text":"\"구조는 변경에 닫혀있고 확장에 열려있어야 한다\" ","italic":true,"bold":false},{"text":"라 말했던 점을 볼 때, 레이아웃은 프론트엔드 개발에서"},{"text":" 가장 ","bold":false},{"bold":true,"text":"더러운 "},{"text":"부분 중 하나입니다.","bold":false}]},{"type":"PARAGRAPH","children":[{"text":"결과적으로,"},{"text":" 레이아웃은 ","bold":false},{"bold":true,"text":"유지보수가 어렵습니다"},{"text":". 레이아웃은 디자인 시스템 바깥의 디자인입니다. 기능이나 테마를 중심으로 모듈화 - 재사용되기도 어렵고, 코드가 직관적이거나 가독성이 좋지도 않습니다. 그럼에도 불구하고 레이아웃을 수정하는 일은 빈번하고, 이는 유지보수에 드는 노력을 크게 증가시킵니다. 가끔 레이아웃의 요구는 잘 정립된 디자인 시스템에 영향을 미치는데, 배치에 따라 기존 요소의 크기, 간격, 줄바꿈이나 스크롤 여부 등을 미세 조정해야하기 때문입니다. 이 경우 개발자는 디자인 시스템 컴포넌트에 커스텀 요소를 계속 추가하거나, 디자이너와 담판을 지어야만 하죠. 어느 쪽이든 소모적이기는 마찬가지입니다."}]},{"type":"PARAGRAPH","children":[{"text":"이 문제를 어떻게 해결할 수 있을까요? CSS의 태생적인 한계 때문에 불가능한 것일까요?"}]},{"type":"PARAGRAPH","children":[{"text":""}]}]},{"id":"5K7u6fkeH4zh1LV6t824K","name":"new box 6","type":"INNER_BOX","layout":{},"look":{},"children":[{"type":"PARAGRAPH","children":[{"text":"Flexbox가 제시하는 레이아웃의 모듈화 방법","bold":true}]},{"type":"PARAGRAPH","children":[{"text":"Flexbox는 CSS에 내재되어 있는 일차원 레이아웃 시스템인 'Flexible Box Module'의 줄임말입니다. 흔히 `display: flex` 속성이 선언된 요소가 가지게 되죠. 이 시스템 자체가 익숙하지 않더라도, 여러분은 캐러셀의 항목들을 가로로 배치하거나 글자를 `<div>` 한가운데로 보낼 때 이 속성을 한 번쯤은 사용해보았을 겁니다. 그러나 이를 Flexbox의 존재 이유라 보기는 어렵습니다.","bold":false}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"이 단락에서는 제가 이해한 Flexbox의 본질을 간략히 설명하고 이 기능이 우리가 레이아웃을 바라보는 방식을 어떻게 바꿀 수 있는 지 설명하고자 합니다. 제가 Flexbox의 설계 의도나 철학을 완전히 이해하고 있는 것은 아니지만, Flexbox를 이용하여 많은 레이아웃을 짜고 또 이를 동료들에게 설명하면서 익힌 노하우가 하나 있습니다. 바로 Flexbox는 내부를 향하여, 또는 내부로부터 가해지는 두 가지 힘을 중심으로 설명하는 게 가장 간단하다는 겁니다. 그리고 이 힘을 바탕으로 우리는 레이아웃을 모듈화하여 위의 문제들을 해결할 실마리를 찾아보겠습니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"text":"Flexbox에서 내부로: 흐름 제어","bold":true}]},{"type":"PARAGRAPH","children":[{"text":"한 번 생각해봅시다. 왜 `<div>`와 같은 블록 요소들의 기본값은 항상 화면의 폭을 가득 채우며 위에서 아래로 배치되는 것일까요? 이 흐름을 우리가 원하는 대로 제어할 수는 없을까요? Flexbox의 핵심은 ","bold":false},{"bold":true,"text":"레이아웃의 흐름"},{"text":"을 `block`이나 `inline`처럼 정해진 방식이 아니라, 사용자가 선언할 수 있게 한다는 점입니다.","bold":false}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"여기서 흐름이란 "},{"bold":true,"text":"일차원 축의 방향"},{"bold":false,"text":"과 여기서 파생되는 "},{"bold":true,"text":"두 가지의 정렬 방식"},{"bold":false,"text":"을 결정하는 것을 의미합니다. 전자는 `flex-direction`속성으로 쉽게 제어할 수 있는데, 여기서 Flexbox는 block 요소와 다르게 가로와 세로, 정방향과 역방향이라는 2*2의 선택지를 제공합니다. 위의 예시 중 캐러셀에 가로로 항목을 배치하는 경우는 이를 이용했다고 볼 수 있겠습니다. 다음으로 정렬은 \b주축(main axis)의 방향에 따라 이에 "},{"bold":true,"text":"수평"},{"bold":false,"text":"인 정렬(justify-content)과 "},{"bold":true,"text":"수직"},{"bold":false,"text":"인 정렬(align-items)의 두 가지 속성이 제공됩니다. Flexbox가 일차원 레이아웃 시스템임에도 불구하고 이차원인 UI의 레이아웃을 온전히 제어할 수 있는 이유는 이처럼 두 요소의 축 방향을 서로 수직이게 설정할 수도 있고, 그 내부의 요소들 또한 수직과 수평의 두 관점에서 정렬할 수 있기 때문입니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"그런데 이처럼 "},{"bold":true,"text":"흐름"},{"bold":false,"text":"을 제어하는 속성들은 곧 Flexbox가 그 내부의 요소들에 가하는 힘입니다. 이들은 Flexbox 자체의 위치나 크기를 결정하지 않지만, 그 자식 요소들의 폭이나 박스 모델에 영향을 줍니다. border-box에서의 padding 속성처럼 말이죠. 물론 정렬 방식에 따라 Flexbox의 길이(=주 축의 수평 방향인 너비)가 달라지기도 하지만 이는 바로 아래에서 논의하도록 하겠습니다. 그렇다면"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"text":"내부에서 Flexbox로: 길이 요청 정책","bold":true}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"여기에 대해 이야기하기 전에 다시 당연한 사실에 대해 의문을 제기해보겠습니다. 대부분의 웹사이트는 세로 방향으로 스크롤이 생기지만, 가로 방향으로는 생기지 않습니다. 왜일까요? 물론 '대부분의 마우스휠은 세로로 스크롤하기가 편해서'와 같은 사용성 측면의 답변도 나올 수 있겠지만, CSS의 관점에서 답변한다면 "},{"bold":true,"text":"웹사이트의 주 축은 세로 방향"},{"bold":false,"text":"이기 때문이라고 말할 수 있을 것입니다. 주 축 방향으로의 스크롤은 자연스럽지만 수직 방향의 스크롤은 어색합니다. 이는 어찌보면 당연한데, 레이아웃은 그 내부의 내용이 얼마나 길어질 지를 제한하지 않아야 하기 때문입니다. 세 문단 이상을 본문에 적을 수 없는 블로그의 레이아웃은 실용적이지 않겠죠. 다섯 개 이상의 할 일을 등록할 수 없는 투두 리스트도 마찬가지입니다. 레이아웃은 아무리 긴 내용도 담을 수 있어야 합니다. 그리고 이 내용은, (inline-block 환경이나 우리가 논하고 있는 Flexbox의 환경 하에서) 언제나 주 축의 방향으로 나열됩니다. 그래서 주 축 방향으로 스크롤이 생기는 상황은 자연스럽게 느껴지는 것입니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"이 이야기를 꺼낸 이유는 Flexbox의 내부, 즉 자식 요소가 Flexbox, 즉 부모 요소에 가하는 힘에 대해 설명하기 위함입니다. 부모 요소가 주 축 방향으로 얼마나 길어질 지, 또는 스크롤을 이용하여 얼마만큼의 길이를 자식 요소에게 확보해줄 지는 부모 요소가 결정할 수 없습니다. 또 자식 요소의 길이를 원하는 대로 결정해서 도 안 되고요. 'justify-content: stretch' 같은 속성이 존재하지 않는 이유도 같은 맥락에서일 겁니다. 대신 이 길이는 자식 요소가 부모에게 요청하고 확보해내며, 그 결과 부모 요소에 스크롤이 생기거나 내부의 내용이 잘리게 됩니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"그렇다면 자식은 어떤 방식으로 부모 요소에게 공간, 즉 길이를 요청하게 될까요? Flexbox의 내부 요소들은 기존의 block처럼 고정된 길이 또는 부모에 대한 비율을 선언하는 대신 훨씬 유연한 방법을 사용할 수 있는데요, 바로 flex-grow, flex-shrink, 그리고 flex-basis를 이용하는 것입니다. flex-basis는 기준이 되는 길이값으로, 기본적으로는 요소의 height(주 축이 가로 방향일 때는 width)처럼 동작합니다. 부모 요소가 주 축 방향으로 가질 수 있는 길이에 여유가 있다면, 부모 요소의 길이는 이 basis의 합으로 자연스럽게 맞춰지겠죠. 그러나 자리가 부족한 경우에는 어떡할까요? 이 때는 자식 요소들이, 본인이 갖고 있는 flex-shrink 값에 비례하게 줄어들게 됩니다(0이면 줄어들 지 않습니다). 반대로 자리가 남으면 flex-grow에 비례하여 길어지게 되고요. 즉 Flexbox의 내부에서 자식 요소들은 여전히 부모 요소에게 basis만큼의 공간을 요구하긴 하지만, grow와 shrink에 따라서 부모 요소의 공간이 작거나 클 때 대응할 확대/축소에 대한 정책도 함께 제공한다는 것입니다. 그 이름처럼 보다 유연하고 너그러운 요청이라고 할 수 있죠."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"flex-grow, flex-shrink, flex-basis를 묶어 우리는 flex라는 단축 속성을 사용할 수 있습니다. Flexbox가 만연하게 사용되는 환경에서 이 단축 속성(특히 앞의 둘)은 요소들의 분류 계통으로써 사용될 수 있는데요, 이해를 돕기 위해 간단한 별명을 붙여 아래에 나열해보겠습니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"bold":true,"text":"1-1족: 친화력이 좋은, 또는 빈 공간"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"`flex: 1 1 ?` 속성을 가진 요소들을 말합니다. 이 요소들은 부모 요소에 남은 공간이 있다면 계속 커지고, 부족하다면 계속 작아집니다. 이 요소는 항목이 늘어나거나 줄어들 수 있는 표의 셀처럼 개수와 형태가 가변적인 화면에 주로 사용됩니다. 그러나 flex-basis 이하로 줄어들 수 있다는 점, 그리고 형제 요소의 계통에 따라 완전히 사라질 수도 있다는 점에서 위험성이 존재하기도 하죠. 이 친구들을 가장 무난하게 사용하는 방법은 바로 다른 여러 1-1족들과 함께 사용하는 것입니다. 이들은 공간이 부족하면 모두 조금씩 줄어들고, 남으면 모두 조금씩 늘어나느 식으로 하여 허용된 공간을 가득 매울 것입니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"이 1-1족들을 사용할 수 있는 재미있는 방식 중 하나는 바로 간격입니다. 가로 Flexbox에서 두 개의 요소를 양쪽 끝에 배치하고 싶을 때, 우리는 보통 'justify-content: space-between'을 사용하곤 하는데요, 그 대신 `flex: 1 1 {최소 간격}`이 적용된 빈 <div> 태그를 사이에 둠으로써 같은 효과를 낼 수도 있습니다. 1-1족을 요소 사이의 빈 공간으로 사용하는 것이죠. 이 방식은 양쪽 요소와 grow의 값을 조정함으로써 자연스럽게 길이를 조절할 수 있는 등 몇 가지의 이점을 제공합니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"bold":true,"text":"0-0족: 딱딱이들"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"이 부류의 요소들은 오직 자신의 flex-basis만큼의 길이를 요구할 뿐, 어떤 유연함도 허용하지 않습니다. 그렇기에 공간이 부족해지거나 남아도 언제나 "},{"bold":true,"text":"고정된 몫"},{"bold":false,"text":"을 차지해야 하는 페이지의 "},{"bold":true,"text":"헤더"},{"bold":false,"text":"나 표의 "},{"bold":true,"text":"라벨"},{"bold":false,"text":"과 같은 요소가 여기로 분류될 수 있습니다. 화면의 내용이 적다고 헤더의 높이가 길어지거나, 반대로 내용이 많다고 헤더의 높이가 줄어들면 좀 이상하겠죠? 이런 요소들은 Flexbox 내부에 있더라도 전혀 유연하지 않은 0-0족으로 구성하는 것이 좋습니다.  또한, 0-0족을 이용하면 부모 요소에 쉽게 스크롤을 생기게 할 수 있습니다. 아래 1-0족과 더불어서 말이죠."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"bold":true,"text":"1-0족: 가득 찬 화면의 주 컨텐츠"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"1-0족은 빈 공간 만큼 늘어나기는 하지만, 절대 flex-basis 이하로 줄어들지는 않습니다. 일종의 최소 길이를 확보하고 있는 것인데요, 이는 본문과 같은 주 컨텐츠에 제일 잘 사용될 수 있습니다. 우리가 무언가로 가득 찬 화면을 만들고 싶다고 해봅시다. 해당 화면에 요소가 부족하다면, 존재하는 요소들이 조금씩 확장하여 화면을 가득 채우면 좋겠죠. 그러나 이 내용들은 중요하기 때문에 또한 잘리거나 너무 작아지는 일이 없어야 합니다. 따라서 1-1족으로 만들기보다는, 주로 `flex: 1 0 auto` 속성을 지닌 1-0족으로 만들어 요소가 너무 많아 붐비는 화면에서는 자연스럽게 부모 요소에 스크롤을 생성하는 게 좋습니다. 본문을 담기에 아주 적절한 종족 아닌가요?"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"bold":true,"text":"0-1족: 장식 요소들"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"제 경험상 자주 사용되는 부류는 아닙니다. flex-basis를 최대 값으로 가지고 있고, 공간이 부족할 경우 자연스럽게 줄어드는 요소들이죠. flex-shrink 값이 존재한다는 점에서 의도한 길이 이하로 줄어들 위험성을 인지해야 합니다. 주로 쓰이는 곳은 그렇게 중요하지 않는 장식적 요소, 그 중에서도 1-1족처럼 계속 늘어날 경우 왜곡되거나 깨질 수 있는 종류의 장식들에 사용될 수 있겠습니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"text":"이러한 분류는 Flexbox의 내부로부터 작용하는 힘, 다시 말해 자식 요소가 부모에게 길이를 요청하는 정책을 바탕으로 UI 컴포넌트들을 나누어 본 것입니다. 이 외에도 여러 특징적인 정책들이 있겠지만 더 나열하지는 않겠습니다. ","bold":false}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"text":"두 가지 힘을 이용한 레이아웃의 모듈화","bold":true}]},{"type":"PARAGRAPH","children":[{"text":"지금까지 Flexbox에 작용하는 두 힘에 대해 알아보았습니다. 이 힘은 Flexbox라는 레이아웃 시스템을 이용하여 화면에 요소들을 배치함에 있어 ","bold":false}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"여기서 주목할 점은 이 두 힘의 주체와 객체가 명확하게 구분된다는 것입니다. 방향과 정렬은 부모가 자식에게 합니다(-self 속성을 이용한 예외가 아니라면 말입니다.) 반대로 주 축 방향으로의 길이는 자식이 부모에게 요청하죠. 이렇게 유연하면서도 엄격한 구조로 레이아웃을 바라보면 우리는 레이아웃의 유지보수가 어렵다는, 글의 첫머리에서 하소연한 고민거리를 해결할 수 있습니다. 그 해결책은 바로 레이아웃의 "},{"bold":true,"text":"모듈화"},{"bold":false,"text":"입니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"스타일링 과정에서 일어나는 모듈화의 대표적인 예시는 디자인 시스템입니다. 프론트엔드 개발자는 디자인 시스템을 바탕으로 연관된 스타일 속성을 묶어 재사용하거나, 버튼이나 제목과 같은 요소 자체를 스타일과 함께 디자인 컴포넌트로 묶어 재사용합니다. 스타일을 모듈화한 것이죠. 그런데 앞서 말했듯 레이아웃은 같은 방식으로 모듈화하기 어렵습니다. 어떤 레이아웃, 즉 어떤 길이와 폭과 overflow 속성과 쌓임 맥락을 가진 화면에 우리의 디자인 컴포넌트가 놓일 지 모르기 때문입니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"하지만 우리가 Flexbox를 이용하여 레이아웃을 작업한다면 모듈화가 가능합니다. 우리는 디자인 컴포넌트를 만들 때, "},{"bold":true,"text":"부모 요소에게 어떤 힘을 가할지"},{"bold":false,"text":" 미리 정해둘 수 있습니다. `flex` 속성을 이용해서 말이죠. 이 컴포넌트가 헤더라면 `flex: 0 0 40px`을, 본문이라면 `flex: 1 0 auto`를 선언해두는 게 적절할 겁니다. 이는 `height: 40px`와 같은 식으로 고정값을 적용하거나 `width: 50%`처럼 어떤 상황일 지 모르는 부모 요소에 모든 것을 맡기는 것보다 훨씬 유연하고 안전합니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"반대로 디자인 컴포넌트를 특정 레이아웃의 맥락 아래 배치할 때에는, `flex-direction`과  각종 정렬 속성을 이용하여 자식 요소에 힘을 가할 수 있습니다. 뿐만 아니라 위의 예시처럼 자식 요소들이 부모 레이아웃에 대해 유연성을 확보하고 있다면, 부모 요소의 크기, padding과 gap을 조정함으로써 자연스럽게 자식 요소의 크기에 영향을 줄 수도 있습니다. 그 때 그 때 디자인 컴포넌트의 스타일링 코드에 if문을 추가하지 않고도 말이죠. 자 이제 우리의 컴포넌트들은 레이아웃에 대해서도 내부와 외부를 격리하고, 서로 독립적으로 "}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"Flexbox가 기존의 문제를 단번에 해결할 만능 열쇠는 아닙니다. 특히 이러한 방식의 레이아웃을 도입하기가 까다로운 점은, 디자이너와 기획자도 "}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"다시 말해 디자인 시스템을 고안하는 과정 자체가 Flexbox에 친화적이어야 합니다. 저는 "}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":""}]},{"type":"PARAGRAPH","children":[{"bold":true,"text":""}]}]},{"id":"inXtGS8859oi3v28PSSoA","name":"new box 7","type":"INNER_BOX","layout":{},"look":{},"children":[{"type":"PARAGRAPH","children":[{"text":"'Pourable' 디자인 시스템","bold":true}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"우리가 작업할 화면에 고정 높이 60px짜리 헤더가 있다고 가정해봅시다. 그 밑으로는 몇 가지의 메뉴 버튼들이 세로 방향으로 나열됩니다. 문제는 우리의 우유부단한 기획자가 어떤 버튼을 이 화면에 노출할 지 고민 중일 때 일어납니다. 일단 세 개의 버튼만 넣자고 하고, 디자이너는 이들이 동일한 높이로 화면을 가득 채우는 것을 상상합니다. 우리는 아래와 같이 코드를 짜게 될 겁니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":".menu-button {"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  height: calc((100% - 60px) / 3)"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"}"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"아뿔싸, 기획자가 버튼 두 개를 추가했습니다. 그런데 디자이너가 그 중 하나는 중요한 버튼이니 크기를 키우자고 하네요. 우리는 코드가 복잡해지는 것에 양심의 가책을 느끼며 주석을 추가합니다."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":".menu-button-normal {"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  height: calc(100% - 80px) / 4; /* 헤더 60px, 큰 버튼은 height 20px 증가  */"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"}"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"그러나 얼마 후 데이터 분석가가 좋지 않은 A/B 테스트 결과를 말해줍니다. 그는 중요하지 않은 버튼 두 개는 한 줄에 배치하고 세로폭을 줄이고, 중심 버튼의 크기는 더욱 키우고자 합니다. 뿐만 아니라 QA 담당자가 세로폭이 좁은 기기에서는 세로 스크롤이 필요하다고 말하네요. 우리는 버튼의 세로폭을 결정하던 기존의 코드를 완전히 뜯어 고쳐야 합니다. 아래와 같은 알 수 없는 속성과 선택자들로 가득한 CSS 파일에서 말이죠."}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":".main-menu-page__menu-button-normal__not-hidden {"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  display: flex;"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  align-items: center;"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  justify-content: center;"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  font-size: var(--typography-label-normal-01);"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  text-align: center;"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  width: 100%;"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  height: calc(100% - 80px) / 4; /* 헤더 60px, 큰 버튼은 height 20px 증가  */"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  background-color: var(--button-background-color-red-01);"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  overflow: hidden;"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"  /* ...그리고 많은 코드들이 더... */"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"}"}]},{"type":"PARAGRAPH","children":[{"bold":false,"text":"그렇게 극단적인 예시만은 아닙니다. "}]}]}]},"createdAt":0,"updatedAt":1737875816731}